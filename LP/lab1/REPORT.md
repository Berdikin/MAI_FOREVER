# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Бердикин Т. А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|   14.11      |       4       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение
Не во всех императивных языках есть списки. Но в тех, в которых они есть, они выглядят совсем иначе, нежели в Прологе. Обычно для работы со списками в императивных языках используются итераторы, да и сам список может содержать элементы лишь одного типа - будь то целый, вещественный или символьный. Пролог предлагает нам иную концепцию: список в Прологе - рекурсивная структура в виде набора значений, которую можно представить в виде дерева. Список в Прологе может содержать элементы любого типа, а задаётся он головой - элементом и хвостом - остальным списком. Ессли он не содержит элемeнтов - он пустой (обозначается []). Можно было бы сравнить список в Прологе с массивами в других языках программирования, но здесь есть разница в доступе - к произвольному элементы массива мы доберёмся за О(1), а к элементу списка только за О(n). 

## Задание 1.1: Предикат обработки списка

`myremoveSTD_3(L, R)` - удаление последних трёх элементов списка c использованием стандартных предикатов
`remove_kebab_3([_],[])` - удаление последних трёх элементов списка без использования стандартных предикатов

Примеры использования:
```prolog
?- myremoveSTD_3([fff, 43, tnh, 685, 3.8, rlyry, 53536], X).
X = [fff, 43, tnh, 685] .

?- remove_kebab_3([fff, 43, tnh, 685, 3.8, rlyry, 53536], [fff, 43, tnh, 685]).
true.

?- remove_kebab_3([456, wfi, et], X).
X = [].
```

Реализация:
```prolog
myremoveSTD_3(L, R):-append(R, X, L), X = [_,_,_].
```
С помощью стандартного предиката append объединяем исходный список и список, состоящий из трёх пустых элементов, тем самым затирая последние три элемента в исходном списке.

```prolog
remove_kebab_3([_],[]) :- !.
remove_kebab_3([_,_],[]) :- !.
remove_kebab_3([_,_,_],[]) :- !.
remove_kebab_3([H|T],[H|Q]) :- remove_kebab_3(T,Q).
```
С помощью рекурсивного отсекания т.н. "головы" мы убираем каждый раз по одному элементу из начала. Затем у нас остаются три элемента в конце, которые мы заменяем на пустой список, т.е. стираем.

## Задание 1.2: Предикат обработки числового списка

`middle(L,A)` - нахождение среднего арифметического элементов списка

Примеры использования:
```prolog
?- middle([1,2,3], X).
X = 2.

?- middle([1,2,8, 212], X).
X = 55.75.

?- middle([1], X).
X = 1.

?- middle([1,2,3,4], 2.5).
true.
```

Реализация:
```prolog
sum([], 0).
sum([H|T], S) :-sum(T, Tail), 
S = Tail + H.
middle(L,A):-sum(L,S), 
length(L,K), 
A is S/K.
```
C помощью вспомогательного предиката sum находим сумму всех элементов списка, затем с помощью стандартного предиката length находим длину и делим первое на второе, получая среднее арифметическое.

## Задание 2: Реляционное представление данных
Сразу бросается в глаза то, что доступ к списку оценок за все предметы или к информации о группе мы получаем за О(1) - это очень хорошо, а вот доступ к оценкам... уже за О(n) - это отрицательная сторона данного представления.

`student_passed(X)` - Х - фамилия студента. Предикат истинен, если студент сдал все экзамены на 3 балла и выше, и ложен, если студент не сдал хотя бы один экзамен. Рекурсивно просматривается список оценок студента по всем предметам. 

`average_mark(G, X, Y)` - G - группа студента(можно опустить, поставив знак нижнего подчёркивания), Х - фамилия студента, Y - средний балл студента по всем предметам.

Рекурсивно просматриваются оценки студента по всем предметам, затем суммируются, а потом полученное число делится на количество предметов(6).

`sub_did_not_passed(X, Y)` - Y - количество студентов, получивших оценку 2 по предмету Х. Создается общий список, содержащий списки из оценок всех студентов по всем предметам. Рекурсивно проверяется, содержится ли в голове списка предмет, по которому получена оценка 2 - если содержится, то Y увеличивается на 1, если нет, то просматривается хвост общего списка.

`max_mark_students(G, L)` - в группе G ищутся студенты, имеющие максимальный средний балл в ней. L - список фамилий этих студентов. Ищется максимальный средний балл в данной группе, после чего ищутся студенты этой группы, имеющие такой средний балл.

## Выводы

Эта лабораторная работа стала для меня первым опытом написания программ на Прологе. Я узнал о реализации многих базовых предикатов этого языка, о списках в Прологе и предикатах работы с ними (таких, как bagof, setof, findall). Было очень сложно понять основное отличие от других языков - понять, что Прологу, в отличие от других языков, не нужно указывать, КАК что-то делать, ему нужно только сказать, ЧТО делать. Здесь, как никогда, понимаешь суть народной мудрости: "Чтобы получить правильный ответ, нужно задать правильный вопрос". И Пролог может дать этот ответ, достаточно лишь написать пару строк, чтобы указать, в каком направлении ему нужно думать. Но, разумеется, чтобы глубже и детальнее изучить возможности Пролога, необходимо больше практики. Также при написании этой лабораторной мне пришлось изучить некоторые книги по логическому программированию. Эта работа дала мне возможность узнать основы логического программирования и удивительного языка Пролог.
