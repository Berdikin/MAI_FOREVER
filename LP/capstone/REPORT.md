# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Бердикин Т.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

При выполнении курсового проекта по логическому программированию я узнал многое. При написании реферата пришлось проделать почти исследовательскую работу и разбудить в себе где-то глубоко дремлющие навыки преподавателя. С выполнением первого задания я понял, что теперь научился обрабатывать данные в формате GEDCOM - это поможет мне в будущем, если я ещё когда-нибудь буду работать с генеалогическими деревьями (надеюсь, что нет, потому что это было достаточно неприятно). Для выполнения второго задания пришлось писать программу-парсер, обрабатывающую это дерево. Изучил даже немного язык Python ради этого. Естественно, закрепил начальные скиллы, связанные с поиском в пространстве состояний и с грамматическим разбором предложений, полученные в 3 и 4 лабораторной работе соответственно.
Ну и, конечно же, теоретическая часть. Не один день был проведён над книгами по логическому программированию, в ходе этого корпения многие знания открылись передо мной. Стало понятно, зачем нужна логическая парадигма и Пролог в частности. Да, наверное, я применю Пролог, когда он будет наилучшим выбором для решения какой-либо задачи.

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: с использованием предиката parents(потомок, отец, мать)
 3. Реализовать предикат проверки/поиска деверей.
 4. [На оценки хорошо и отлично]Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

С трудом вспомнил пароль от MyHeritage, дополнил дерево, экспортировал в формат GEDCOM c помощью специальной кнопки и готово. В дереве получилось больше 50 человек!

## Конвертация родословного дерева
Здесь было бы целесообразно использовать язык Си, изученный мною на первом курсе, но, поддавшись уговорам одногруппниц, я провёл вечер в общежитии за написанием программы-парсера на Python'e - языке, которого я до этого не знал.
Но программа работает предельно просто: построчно проходя по файлу, мы находим id человека, его имя и фамилию и добавляем эту информацию в словарь, и через отношения "муж-жена" (HUSB, WIFE) и "ребёнок" (СHILD) понимаем, кто есть кто и печатаем предикат parents (X, Y, Z), где Х - ребёнок, а Y и Z - его родители.

## Предикат поиска родственника

Кто такой деверь? Для женщины это брат её мужа.
Для того, чтобы найти всех деверей, определяем сначала с помощью предиката doughter список дочерей (то есть, лиц женского пола). Затем определяем поиск мужей и братье, а потом с помощью правила dever сливаем это воедино. Потом определяем предикат для поиска всех деверей и ещё предикат, отсеивающий дубли. И ещё несколько предикатов для итогового списка отношений и вывода всех деверей.

## Определение степени родства
Используем поиск в ширину для того, чтобы найти кратчайшее отношение родства. Реализуем предикаты check_link, для определения прямых отношений между двумя людьми. В итоге у нас есть проверка отношений муж, жена, брат/сестра, отец, мать, ребенок, родитель. Далее находится цепочка родственников, по которой и связаны эти люди, затем эту цепочку переводим в цепочку родства и получается ответ. Подробнее в файле 3-4.pl
Результаты работы: 
```prolog
?- relative('Сергей Самсонов', 'Тимофей Бердикин', X).
X = [child, subling, mother].

?- relative_thread('Сергей Самсонов', 'Тимофей Бердикин', X).
X = ['Сергей Самсонов', 'Наталья Грынина', 'Екатерина Грынина', 'Тимофей Бердикин'].

?- check_link(subling, 'Тимофей Бердикин', X).
X = 'Иван Бердикин'.

?- transform(['Сергей Самсонов', 'Наталья Грынина', 'Екатерина Грынина', 'Тимофей Бердикин'], X).
X = [child, subling, mother].
```


А предикат `transform` покажет вам, как связаны между собой родственники в той цепочке, которую вы получили. к примеру, данный результат расшифровывается примерно следующим образом: Сергей Самсонов является сыном Натальи Грыниной, которая является сестрой Екатерины Грыниной, которая является мамой Тимофея Бердикина. Видите, как просто?

Примечание: не знаю, что делать с этим Markdown, чтобы он нормально выделял код. Если вы это читаете, то помогите поправить, пожалуйста)
## Естественно-языковый интерфейс
Не осилил, к сожалению. Но очень хотел.
## Выводы

О том, что я научился делать, я подробно рассказал в самом начале. Общие выводы таковы: я научился работать с Прологом и познал довольно интересную и трудную парадигму логического программирования - вывод информации на основе заданных фактов и в соответствии с правилами вывода.
Эта работа - реальная задача, в которой понадобился Пролог. И я с ней справился, пусть и не на высоком уровне.
