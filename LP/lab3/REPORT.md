#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Бердикин Т.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|     14/12    |       4-      |


## Введение

Для решения задач, представление которых можно описать набором некоторых состояний объектов, можно применять различные алгоритмы поиска в графах. Так, граф можно легко получить, если определить состояния, как его вершины, а дуги, как переходы из одного состояния в другое. Так как любой алгоритм поиска представляет из себя нахождение пути из одной вершины в другую, то в рамках задачи этот путь является ответом на то, какими переходами из одних состояний в другие можно достичь конечного состояния. Таким способом можно легко решать задачи на перемещения объектов из одного места в другое: пятнашки, задача о волке, козе и капусте, задача о коммивояжёре(хоть и не очень эффективно). Благодаря тому, что поиск решения на Prolog'е основан на обходе дерева, подобные задачи легко решаются использованием алгоритмов поиска. Если при поиске была достигнута вершина(состояние), из которого дальше пути нет, то необходимо откатиться до какого-то предыдущего состояния, которое определяется алгоритмом. Такой процесс backtracing'а заложен "внутри" Prolog'а, поэтому нет необходимости писать в программе дополнительный код. Именно поэтому Prolog является отличным средством для решения подобных задач.

## Задание

Железнодорожный сортировочный узел устроен так, как показано на рисунке. На левой стороне собрано некоторое число вагонов двух типов(черные и белые), обоих типов по n штук, в произвольном порядке. Тупик вмещает все 2n вагонов. Пользуясь тремя сортировочными операциями (слева в тупик, из тупика направо, слева направо, минуя тупик), собрать вагоны на правой стороне, так, чтобы типы чередовались. Для решения задачи достаточно 3n-1 сортировочных операций.

## Принцип решения

`% ПОИСК В ГЛУБИНУ

dpth([X|T], X, [X|T]).
dpth(From, To, Way):-
    prolong(From, Tmp), dpth(Tmp, To, Way).

search_dpth(From, To):-
    dpth([From], To, Way), answer(Way).

search_dpth_time(From, To):-
    get_time(S1), dpth([From], To, Way), get_time(F1),
    T1 is F1 - S1, write('TIME: '), write(T1), nl.;`

C помощь предиката dpth осуществляем сам поиск: продлеваем путь, пока не будет достигнута точка конечного состояния или пока дальнейший поиск не станет невозможным. Предикат search_dpth запускает сам поиск и выводит найденные решения. Предикат search_dpth_time отслеживает время выполнения поиска.

`% ПОИСК В ШИРИНУ

bdth([[To|Way]|_], To, [To|Way]).
bdth([FirstWay|QI], To, Way):-
    findall(OtherWay, prolong(FirstWay, OtherWay), PossibleWays),
    append(QI, PossibleWays, QO), !, bdth(QO, To, Way).
bdth([_|Other], To, Way):- bdth(Other, To, Way).

search_bdth(From, To):-
    bdth([[From]], To, Way), answer(Way).

search_bdth_time(From, To):-
    get_time(S2), bdth([[From]], To, Way), get_time(F2),
    T2 is F2 - S2, write('TIME: '), write(T2), nl.`

bdth - поиск в ширину, где мы рассматриваем очередь путей, и каждый путь из начала очереди продлеваем всеми возможными способами и помещаем в конец очереди, к полученной очереди поиск применяется рекурсивно! Возвращается обычно первый путь, если он оказывается искомым. А если его невозможно продлить, переходим к последующим путям. search_bdth - поиск с выводом решения, search_bdth_time - дополнительно с замером времени.

`% ПОИСК С ИТЕРАЦИОННЫМ ЗАГЛУБЛЕНИЕМ

depth_id([To|T], To, [To|T], _).%:- answer([To|T]).
depth_id(Way, To, Res, N):- N > 0,
    prolong(Way, NewWay), N1 is N - 1,
    depth_id(NewWay, To, Res, N1).

search_id(From, To, Way, Limit):-
    depth_id([From], To, Res, Limit).

my_integer(1).
my_integer(M):- my_integer(N), M is N + 1.

search_id_time(From, To):-
    get_time(S3),
    my_integer(Lvl),
    search_id(From, To, Way, Lvl),
    get_time(F3), T3 is F3 - S3,
    write('TIME: '), write(T3), nl.`
    
    Итеративное погружение - это модификация поиска в глубину, теперь там указывается глубина поиска. Чтобы проследить путь решения, необходимо вывести из-под комментария часть первой строки и воспользоваться предикатом search_id. searh_id_time - вы знаете, что он делает.
    
    Источник: Д.В.Сошников. Парадигма логического программирования.
    
## Результаты

Результаты работы алгоритмов, как и следовало ожидать, практически идентичны. Важно отметить, что определённые правила были поставлены в условии не просто так, а чтобы существенно сократить время поиска. Не было бы этих правил - можно было бы двигать всё, как захочется, и число вариантов решения очень быстро бы устремлялось к бесконечности.

## Выводы
Для решения данной задачи нет разницы, какой из алгоритмов поиска использовать. Но, так как в условии сказано, что достаточно 3n-1 перестановок поездов, то было бы разумно использовать поиск с итерационным заглублением. Таким образом, всевозможные пути длиннее данной величины будут точно отсечены и не попадут в ответ. Но, как я уже сказал, это излишне, так как 3 условия перехода обеспечивают нужный результат.

Данная лабораторная работа помогла мне лучше понять принцип работы данных алгоритмов поиска в графе, так как их реализация на Prolog'е наглядно это демонстрирует. Подобные алгоритмы я могу использовать и дальше, в том числе и в моей курсовой работе, где вершинами графа являются мои родственники из родословного дерева, а связями их родственные отношения. Это существенно облегчает задачу поиска отношения двух различных людей в нём.




